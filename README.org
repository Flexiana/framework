#+TITLE: README
#+AUTHOR: lambdart
#+EMAIL: lambdart@protonmail.com
#+DESCRIPTION: Flexiana WebApp Framework
#+KEYWORDS: clojure webapp framework
#+LANGUAGE: en
#+BABEL: :cache yes
#+STARTUP: overview

* Introduction

  Xiana is a lightweight web-application framework written in Clojure LISP,
  its goal is to be simple, blasting fast, and most important - a welcome
  platform for web programmers from different backgrounds that want to
  experience the wonders of functional programming!

  It's easy to install, fun to experiment and a powerful
  tool to produce reliable code for the word wild web.

* Dependencies
** System
*** Mandatory

    - Clojure 1.10
    - Postgresql >= 11.5

*** Optional

    - Docker >= 19.03.11
    - Docker-compose >= 1.21.0

** Clojure
*** Tools

    | Name      | Version | Description     |
    | leiningen |   2.9.0 | Project Manager |

*** Libraries
**** Mandatory

     | Name                            | Version | Related    |
     | funcool/cats                    |   2.4.1 | Monad      |
     | funcool/cuerdas                 | RELEASE | Monad      |
     | metosin/reitit                  |  0.5.12 | Routes     |
     | potemkin/potemkin               |   0.4.5 | Helper     |
     | com.draines/postal              |   2.0.4 | Email      |
     | duct/server.http.jetty          |   0.2.1 | WebServer  |
     | seancorfield/next.jdbc          | 1.1.613 | WebServer  |
     | honeysql/honeysql               | 1.0.444 | PostGreSQL |
     | nilenso/honeysql-postgres       |   0.2.6 | PostGreSQL |
     | org.postgresql/postgresql       |  42.2.2 | PostGreSQL |
     | crypto-password/crypto-password |   0.2.1 | Security   |

**** Optional

     | Name                | Version | Provide |
     | clj-kondo/clj-kondo | RELEASE | Tests   |

* Development
** Setup
*** QuickStart

    #+BEGIN_SRC sh
    $ git clone git@github.com:Flexiana/framework.git; cd framework
    $ ./script/auto.sh -y all
    #+END_SRC

    The first command will fetch the ~Flexiana/framework~ repository and jump
    to its directory. The second command calls ~auto.sh~ script to perform the
    following sequence of steps:

    1. Download the necessary docker images
    2. Instantiate the database container
    3. Import the initial SQL schema: ~./docker/sql-scripts/init.sql~
    4. Populate the new schema with 'fake' data from: ~./docker/sql-scripts/init.sql~
    5. Call =lein test= that will download the necessary *Clojure*
       dependencies and will execute all the unitary tests.

    See ~./script/auto.sh help~ for more advanced options.

    Remember it's necessary to have =docker/docker-compose= installed in your
    host machine. Docker daemon should be initialize a priori, otherwise this
    whole chain of commands will fail.

    It should also be noted that after the first installation everything will
    be cached preventing unnecessary rework, it's possible to run only
    the tests if your development environment is already up,
    increasing the overall productivity.

    #+BEGIN_SRC sh
    ./script/auto.sh -y tests
    #+END_SRC

*** CLI

    We define some aliases to make possible to use ~deps.edn~ directly
    (recommend).

*** Docker/Compose
*** Leinigen

    Using lein directly is very simple:

    #+BEGIN_SRC sh
    lein test
    #+END_SRC

    The available commands (aliases):

    | Aliases | Command   | Description       |
    | run     | lein run  |                   |
    | test    | lein test | Invoke tests      |

** Hello World

   Mandatory =hello-word= example:

   #+BEGIN_SRC clojure

   (ns framework.app.example
     (:require
      ;; mandatory modules to build/run any web application
      [xiana.core :as xiana]
      [framework.route.core :as route]
      [framework.webserver.core :as webserver]))

   ;; application route definitions
   (def app-routes
     [["/" {:action
            #(xiana/ok
              (-> % (assoc :response
                           {:status 200 :body "Hello Word!"})))}]])

   (defn -main
     "Application entry point."
     []
     ;; setup app routes
     (route/reset app-routes)
     ;; start app webserver
     (webserver/start []))

   #+END_SRC

   The first line defines the application and the following =:require=
   expression imports the necessary modules to build/run this simple
   web application example.

   The most common web applications will use the following components:

   - Xiana (Monads)
   - State (Context)
   - Routes (URI)
   - Interceptors (Helpers)
   - WebServer (Http Request)
   - Postgresql (Database)

   More details in the sections below.

** Flow
* Framework
** Concepts
*** Monads

    "Monad is a simple and powerful mechanism for function composition that
    helps us to solve very common IT problems such as input/output, exception
    handling, parsing, concurrency and other. Application becomes less error prone.
    Code becomes reusable and more readable."

    And we use it to do exactly that: to add *Failure* / *Success* metadata
    to our internal wrapped *state*, our data flow unity.

    Think of it as a ~container~ that's compose by ~metadata~ plus
    its data value, and every function that returns the *state* map needs
    to wrapper it first providing the right binary direction *Success* or
    *Failure*.

    This is done by the functions: ~xiana/ok~ and ~xiana/error~ respectively
    defined in ~xiana/core.clj~.

    The container will travel through the application and dictates
    how it will operates based on its binary direction values and
    the *state* map.

*** State

    A simple map that is created for each *HTTP* request
    and represents the current *state* of the application
    in a given time, remember this structure is very volatile, i.e,
    will be updated quite often on the application's life cycle.

    The main modules that updates the *state*:

    - Routes:
      Add information from the match route to the *state* map,
      for example: route's action handler function.

    - Interceptors
      Add, consumes or remove information from the *state* map,
      more details on the *Interceptors* section.

    In a nutshell the *state* is just a map that holds information in the
    application data flow cycle, its final stage extracts the response value
    from the container and the rest of the data remaining data
    will be discarded, because each new request creates
    a new clean *state* map.

    Probably you're under: why not just call it *context*? Go figure :),
    but putting jokes aside, this nomenclature will probably change in the
    near future.

*** Config

    The configuration module controls the resources options and its
    specifications values, that will be fetched at run time by the
    resources modules - *server/database* - in their initialization
    processes, by adding this layer of abstraction we provide a simple,
    robust, and extensible mechanisms to manage our configuration
    data.

    So, we use the same and well know ~.edn~ file map that simplifies
    everything, maintaining a certain degree of legibility.

    The default development configuration file can be found at:
    ~./config/dev/config.edn~.

    NOTE: It's highly recommended to read the ~config.edn~ file and at least
    understand the basic syntax and its implications (options/specs), specially
    if you want to work on the core development of the framework.

    The environment variable =FRAMEWORK_EDN_CONFIG= holds the file path
    definition and can be easily changed before the call of any auxiliary
    command, e.g:

    #+BEGIN_SRC sh
    env FRAMEWORK_EDN_CONFIG=./config/prod/config.edn lein test
    #+END_SRC

    That way it's very simple to extend the framework without concert to much
    about where and how this data will be used.

*** Routes
*** Interceptors
*** Resources
**** Webserver
**** Database
** Architecture
*** File-Tree

    This is the current directory tree architecture, remember to update
    this block after every significant update!

    #+BEGIN_SRC
    .
    ├── framework
    │   ├── app
    │   │   ├── core.clj
    │   │   ├── controllers
    │   │   ├── helpers
    │   │   ├── models
    │   │   └── view
    │   │       └── css
    │   │           └── tailwind
    │   │               ├── core.cljc
    │   │               ├── helpers.cljc
    │   │               ├── preparers.cljc
    │   │               └── resolvers.cljc
    │   ├── auth
    │   │   └── hash.clj
    │   ├── config
    │   │   └── core.clj
    │   ├── db
    │   │   ├── core.clj
    │   │   ├── postgresql.clj
    │   │   └── sql.clj
    │   ├── interceptor
    │   │   ├── core.clj
    │   │   ├── helpers.clj
    │   │   ├── muuntaja.clj
    │   │   ├── queue.clj
    │   │   └── wrap.clj
    │   ├── mail
    │   │   └── core.clj
    │   ├── route
    │   │   ├── core.clj
    │   │   └── helpers.clj
    │   ├── session
    │   │   └── core.clj
    │   ├── state
    │   │   └── core.clj
    │   └── webserver
    │       └── core.clj
    └── xiana
        ├── commons.clj
        └── core.clj
    #+END_SRC

* Contributions
* LICENSE
* References

  1. https://clojuredocs.org/clojure.edn/read
  2. http://funcool.github.io/cats/latest/
  3. https://medium.com/@yuriigorbylov/monads-and-why-do-they-matter-9a285862e8b4

* EOF
