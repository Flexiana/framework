<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Tutorials</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" type="text/css" href="css/xiana.css" /></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name"></span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="welcome.html"><div class="inner"><span>Xiana framework</span></div></a></li><li class="depth-1 "><a href="conventions.html"><div class="inner"><span>Conventions</span></div></a></li><li class="depth-1  current"><a href="tutorials.html"><div class="inner"><span>Tutorials</span></div></a></li><li class="depth-1 "><a href="contribution.html"><div class="inner"><span>Contribution</span></div></a></li><li class="depth-1 "><a href="getting-started.html"><div class="inner"><span>How to make a Todo app using Xiana</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>xiana</span></div></div></li><li class="depth-2 branch"><a href="xiana.coercion.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>coercion</span></div></a></li><li class="depth-2 branch"><a href="xiana.commons.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>commons</span></div></a></li><li class="depth-2 branch"><a href="xiana.config.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>config</span></div></a></li><li class="depth-2 branch"><a href="xiana.cookies.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cookies</span></div></a></li><li class="depth-2"><a href="xiana.db.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>db</span></div></a></li><li class="depth-3"><a href="xiana.db.migrate.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>migrate</span></div></a></li><li class="depth-2 branch"><a href="xiana.handler.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>handler</span></div></a></li><li class="depth-2 branch"><a href="xiana.hash.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>hash</span></div></a></li><li class="depth-2"><a href="xiana.interceptor.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>interceptor</span></div></a></li><li class="depth-3 branch"><a href="xiana.interceptor.error.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>error</span></div></a></li><li class="depth-3 branch"><a href="xiana.interceptor.muuntaja.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>muuntaja</span></div></a></li><li class="depth-3 branch"><a href="xiana.interceptor.queue.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>queue</span></div></a></li><li class="depth-3"><a href="xiana.interceptor.wrap.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>wrap</span></div></a></li><li class="depth-2 branch"><a href="xiana.mail.html"><div class="inner"><span class="tree" style="top: -145px;"><span class="top" style="height: 154px;"></span><span class="bottom"></span></span><span>mail</span></div></a></li><li class="depth-2 branch"><a href="xiana.rbac.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rbac</span></div></a></li><li class="depth-2"><a href="xiana.route.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>route</span></div></a></li><li class="depth-3"><a href="xiana.route.helpers.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>helpers</span></div></a></li><li class="depth-2 branch"><a href="xiana.scheduler.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>scheduler</span></div></a></li><li class="depth-2 branch"><a href="xiana.session.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>session</span></div></a></li><li class="depth-2 branch"><a href="xiana.sse.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sse</span></div></a></li><li class="depth-2 branch"><a href="xiana.state.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>state</span></div></a></li><li class="depth-2 branch"><a href="xiana.webserver.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>webserver</span></div></a></li><li class="depth-2"><a href="xiana.websockets.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>websockets</span></div></a></li><li class="depth-3"><a href="xiana.websockets.router-helpers.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>router-helpers</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><p><img src="resources/images/Xiana.png" width="242" /></p>
<h1><a href="#tutorials" id="tutorials"></a>Tutorials</h1>
<ul>
<li><a href="#application-startup">Application startup</a></li>
<li><a href="#configuration">Configuration</a></li>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#defining-new-interceptors">Defining new interceptors</a>
<ul>
<li><a href="#interceptor-example">Interceptor example</a></li>
</ul>
</li>
<li><a href="#router-and-controller-interceptors">Router and controller interceptors</a></li>
<li><a href="#providing-default-interceptors">Providing default interceptors</a></li>
<li><a href="#interceptor-overriding">Interceptor overriding</a></li>
<li><a href="#routes">Routes</a></li>
<li><a href="#action">Action</a></li>
<li><a href="#database-migration">Database migration</a></li>
<li><a href="#database-access">Database-access</a></li>
<li><a href="#view">View</a></li>
<li><a href="#side-effects">Side-effects</a></li>
<li><a href="#session-management">Session management</a>
<ul>
<li><a href="#in-memory-session-backend">In memory backend</a></li>
<li><a href="#persistent-session-backend">Persistent backend</a></li>
<li><a href="#session-interceptors">Session interceptors</a></li>
</ul>
</li>
<li><a href="#role-based-access-and-data-ownership-control">Role based access and data ownership control</a></li>
<li><a href="#websockets">WebSockets</a>
<ul>
<li><a href="#websockets-routing">WebSockets routing</a></li>
<li><a href="#route-matching">Route matching</a></li>
</ul>
</li>
<li><a href="#server-sent-events-sse">Server-Sent Events (SSE)</a></li>
<li><a href="#scheduler">Scheduler</a></li>
<li><a href="#login-implementation">Login implementation</a></li>
<li><a href="#logout-implementation">Logout implementation</a></li>
<li><a href="#access-and-data-ownership-control">Access and data ownership control</a>
<ul>
<li><a href="#role-set-definition">Role set definition</a></li>
<li><a href="#provide-resourceaction-at-routing">Provide resource/action at routing</a></li>
<li><a href="#application-start-up">Application start-up</a></li>
<li><a href="#access-control">Access control</a></li>
<li><a href="#data-ownership">Data ownership</a></li>
</ul>
</li>
</ul>
<h2><a href="#application-startup" id="application-startup"></a>Application startup</h2>
<p>Starting up an application takes several well-defined steps:</p>
<ul>
<li>reading the configuration</li>
<li>setting up dependencies</li>
<li>spinning up a web-server</li>
</ul>
<h2><a href="#configuration" id="configuration"></a>Configuration</h2>
<p>Apps built with Xiana are configurable in several ways. It uses <a href="https://github.com/yogthos/config">yogthos/config</a> to resolve basic configuration from <code>config.edn</code>, <code>.lein-env</code>, <code>.boot-env</code> files, environment variables and system properties. Additionally</p>
<ul>
<li>Xiana looks for an <code>.edn</code> file pointed with <code>:xiana-config</code> variable for overrides</li>
<li>You can define a key to read from any other (already defined) value, and/or pass a default value.</li>
</ul>
<p>In practice this means you can define a config value like this:</p>
<pre><code class="language-clojure">:xiana/test {:test-value-1 "$property"
             :test-value-2 "$foo | baz"}
</code></pre>
<p>and this will be resolved as</p>
<pre><code class="language-clojure">:xiana/test {:test-value-1 "the value of 'property' key, or nil"
             :test-value-2 "the value of `foo` key or \"baz\""}
</code></pre>
<p>The value of property key can come from the config files, environment variables, or from system properties.</p>
<h2><a href="#dependencies" id="dependencies"></a>Dependencies</h2>
<p>Database connection, external APIs or session storage, the route definition, setting up scheduled executors or doing migrations are our dependencies. These dependencies should be reachable via the passed around state. To achieve this, it should be part of the <code>:deps</code> map in the state. Any other configuration what you need in runtime should be part of this map too.</p>
<p>The system configuration and start-up with the chainable set-up:</p>
<pre><code class="language-clojure">(defn -&gt;system
  [app-cfg]
  (-&gt; (config/config app-cfg)                    ;Read config
      routes/reset                               ;set up routing
      db/start                                   ;set up database connection
      db/migrate!                                ;running migrations
      session/init-backend                       ;initialize session storage
      (scheduler/start actions/ping 10000)       ;starting a scheduler
      ws/start))                                 ;spinning up the webserver

(def app-cfg
  {:routes                  routes                              ;injecting route definition
   :router-interceptors     []                                  ;definition of router interceptors
   :controller-interceptors [(xiana-interceptors/muuntaja)      ;definition of controller interceptors
                             cookies/interceptor
                             xiana-interceptors/params
                             session/interceptor
                             xiana-interceptors/view
                             xiana-interceptors/side-effect
                             db/db-access]})

(defn -main
  [&amp; _args]
  (-&gt;system app-cfg))                                           ;starting the application
</code></pre>
<h2><a href="#defining-new-interceptors" id="defining-new-interceptors"></a>Defining new interceptors</h2>
<p>The interceptor is a map, can have three functions like:</p>
<p><code>:enter</code> Runs while we are going down from the request to it’s action, in the order of executors</p>
<p><code>:leave</code> Runs while we’re going up from the action to the response.</p>
<p><code>:error</code> Executed when any error thrown while executing the two other functions</p>
<p>and a <code>:name</code> can be defined. All keys are optional, and if it missing it’s replaced by <code>identity</code>.</p>
<p>The provided functions are should have one parameter, the application state, and should return the modified state.</p>
<h3><a href="#interceptor-example" id="interceptor-example"></a>Interceptor example</h3>
<pre><code class="language-clojure">
{:name  :sample-interceptor
 :enter (fn [state]
          (println "Enter: " state)
          (-&gt; state
              (transform-somehow)
              (or-do-side-effects)))
 :leave (fn [state]
          (println "Leave: " state)
          state)
 :error (fn [state]
          (println "Error: " state)
          ;; Here `state` should have previously thrown exception
          ;; stored in `:error` key.
          ;; you can do something useful with it (e.g. log it)
          ;; and/or handle it by `dissoc`ing from the state.
          ;; In that case remaining `leave` interceptors will be executed.
          (assoc state :response {:status 500 :body "Error occurred while printing out state"}))}
</code></pre>
<h2><a href="#router-and-controller-interceptors" id="router-and-controller-interceptors"></a>Router and controller interceptors</h2>
<p>The router and controller interceptors are executed in the exact same order (enter functions in order, leave functions in reversed order), but not in the same place of the execution flow. Router interceptors are executed around Xiana’s router, controller interceptors executed around the defined action.</p>
<ol>
<li>router interceptors :enter functions in order</li>
<li>router interceptors :leave functions in reversed order</li>
<li>routing, and matching</li>
<li>controller interceptors :enter functions in order</li>
<li>action</li>
<li>controller interceptors :leave functions in reversed order</li>
</ol>
<p>In router interceptors, you are able to interfere with the routing mechanism. Controller interceptors can be interfered with via route definition. There is an option to define interceptors around creating WebSocket channels, these interceptors are executed around the <code>:ws-action</code> instead of <code>:action</code>.</p>
<h2><a href="#providing-default-interceptors" id="providing-default-interceptors"></a>Providing default interceptors</h2>
<pre><code class="language-clojure">{:router-interceptors     [...]
 :controller-interceptors [...]
 :web-socket-interceptors [...]}
</code></pre>
<h2><a href="#interceptor-overriding" id="interceptor-overriding"></a>Interceptor overriding</h2>
<p>On route definition you can interfere with the default controller interceptors. With the route definition you are able to set up different controller interceptors other than the ones already defined with the app. There are three ways to do it:</p>
<pre><code class="language-clojure">... {:action       #(do something)
     :interceptors [...]}
</code></pre>
<p>will override all controller interceptors</p>
<pre><code class="language-clojure">... {:action       #(do something)
     :interceptors {:around [...]}}
</code></pre>
<p>will extend the defaults around</p>
<pre><code class="language-clojure">... {:action       #(do something)
     :interceptors {:inside [...]}}
</code></pre>
<p>will extend the defaults inside</p>
<pre><code class="language-clojure">... {:action       #(do something)
     :interceptors {:inside [...]
                    :around [...]}}
</code></pre>
<p>will extend the defaults inside and around</p>
<pre><code class="language-clojure">... {:action       #(do something)
     :interceptors {:except [...]}}
</code></pre>
<p>will skip the excepted interceptors from defaults</p>
<h2><a href="#routes" id="routes"></a>Routes</h2>
<p>Route definition is done via <a href="https://github.com/metosin/reitit">reitit’s routing</a> library. Route processing is done with <code>xiana.route</code> namespace. At route definition you can define.</p>
<ul>
<li>The <a href="#action">action</a> that should be executed</li>
<li><a href="#interceptor-overriding">Interceptor overriding</a></li>
<li>The required permission for <a href="#role-based-access-and-data-ownership-control">rbac</a></li>
<li><a href="#websockets">WebSockets</a> action definition</li>
</ul>
<p>If any extra parameter is provided here, it’s injected into</p>
<pre><code class="language-clojure">(-&gt; state :request-data :match)
</code></pre>
<p>in routing step.</p>
<p>Example route definition:</p>
<pre><code class="language-clojure">["/api" {}
 ["/login" {:post {:action       #'user-controllers/login                     ;Login controller
                   :interceptors {:except [session/interceptor]}}}]           ;the user doesn't have a valid session yet
 ["/posts" {:get    {:action     #'posts-controllers/fetch                    ;controller definition for fetching posts
                     :permission :posts/read}                                 ;set up the permission for fetching posts
            :put    {:action     #'posts-controllers/add
                     :permission :posts/create}
            :post   {:action     #'posts-controllers/update-post
                     :permission :posts/update}
            :delete {:action     #'posts-controllers/delete-post
                     :permission :posts/delete}}]
 ["/notifications" {:get {:ws-action  #'websockets/notifications               ;websocket controller for sending notifications
                          :action     #'notifications/fetch                    ;REST endpoint for fetching notifications
                          :permission :notifications/read}}]                   ;inject permission
 ["/style" {:get {:action       #'style/fetch
                  :organization :who}}]]                                       ;this is not a usual key, the value will go to 
;(-&gt; state :request-data :match :organization) 
;at the routing process 
</code></pre>
<h2><a href="#action" id="action"></a>Action</h2>
<p>The action function (controller) in a single <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete#RESTful_APIs">CRUD application</a> is for defining a <a href="#view">view</a>, a <a href="#database-access">database-query</a> (model) and optionally a <a href="#side-effects">side-effect</a> function which will be executed in the following interceptor steps.</p>
<pre><code class="language-clojure">(defn action
  [state]
  (assoc state :view view/success
               :side-effect behaviour/update-sessions-and-db!
               :query model/fetch-query))
</code></pre>
<h2><a href="#database-migration" id="database-migration"></a>Database migration</h2>
<p>Database migration is based on the following principles:</p>
<ol>
<li>The migration process is based on a stack of immutable changes. If at some point you want to change the schema or the content of the database you don’t change the previous scripts but add new scripts at the top of the stack.</li>
<li>There should be a single standard resources/migrations migration directory</li>
<li>If a specific platform (dev, stage, test, etc) needs additional scripts, specific directories should be created and in config set the appropriate migrations-dir as a vector containing the standard directory and the auxiliary directory.</li>
<li>The order in which scripts are executed depends only on the script id and not on the directory where the script is located</li>
</ol>
<h3><a href="#configuration" id="configuration"></a>Configuration</h3>
<p>The migration process requires a config file containing:</p>
<pre><code class="language-clojure">:xiana/postgresql {:port     5432
                   :dbname   "framework"
                   :host     "localhost"
                   :dbtype   "postgresql"
                   :user     "postgres"
                   :password "postgres"}
:xiana/migration {:store                :database
                  :migration-dir        ["resources/migrations"]
                  :init-in-transaction? false
                  :migration-table-name "migrations"}
</code></pre>
<p>The :migration-dir param is a vector of classpath relative paths containing database migrations scripts.</p>
<h3><a href="#usage" id="usage"></a>Usage</h3>
<p>The <code>xiana.db.migrate</code> implements a cli for migrations framework.</p>
<p>If you add to <code>deps.edn</code> in <code>:aliases</code> section:</p>
<pre><code class="language-clojure">:migrate {:main-opts ["-m" "xiana.db.migrate"]}
</code></pre>
<p>you could access this cli from clojure command.</p>
<p>To see all commands and options available run:</p>
<pre><code class="language-shell">clojure -M:migrate --help
</code></pre>
<p>Examples of commands:</p>
<pre><code class="language-shell"># update the database to current version:
clojure -M:migrate migrate -c resources/config.edn
# rollback the last run migration script:
clojure -M:migrate rollback -c resources/config.edn
# rollback the database down until id script: 
clojure -M:migrate rollback -i 20220103163538 -c resources/config.edn
# create the migrations scripts pair: 
clojure -M:migrate create -d resources/migrations -n the-name-of-the-script
</code></pre>
<h2><a href="#database-access" id="database-access"></a>Database access</h2>
<p>The <code>xiana.db/db-access</code> executes queries from <code>:query</code> (for single, non-transactional database access) and <code>:db-queries</code> in this order against the datasource extracted from state. The result will be available in <code>(-&gt; state :response-data :db-data)</code> which is always a sequence.</p>
<p><code>db-queries</code> is still a map, contains <code>:queries</code> and <code>:transaction?</code> keys. If <code>:transaction?</code> is set to <code>true</code>, all <code>queries</code> in <code>db-queries</code> will be executed in one transaction.</p>
<p>The query should be in <a href="https://github.com/nilenso/honeysql-postgres">honey SQL</a> format, it will be sql-formatted on execution:</p>
<pre><code class="language-clojure">(-&gt; (select :*)
    (from :users)
    (where [:and
            :is_active
            [:or
             [:= :email login]
             [:= :username login]]]))
</code></pre>
<p>is equal to</p>
<pre><code class="language-clojure">{:select [:*]
 :from   [:users]
 :where  [:and
          :is-active
          [:or
           [:= :email login]
           [:= :user-name login]]]}
</code></pre>
<p>Both examples above are leads to</p>
<pre><code class="language-postgres-sql">["SELECT * FROM users WHERE is_active AND (email = ? OR user_name = ?)" login login] 
</code></pre>
<h2><a href="#view" id="view"></a>View</h2>
<p>A view is a function to prepare the final response and saving it into the state based on whatever happened before.</p>
<pre><code class="language-clojure">(defn success
  [state]
  (let [{:users/keys [id]} (-&gt; state :response-data :db-data first)]
    (assoc state :response {:status 200
                            :body   {:view-type "login"
                                     :data      {:login   "succeed"
                                                 :user-id id}}})))
</code></pre>
<h2><a href="#side-effects" id="side-effects"></a>Side-effects</h2>
<p>Conventionally, side-effects interceptor is placed after <a href="#action">action</a> and <a href="#database-access">database-access</a>, just right before <a href="#view">view</a>. At this point, we already have the result of database execution, so we are able to do some extra refinements, like sending notifications, updating the application state, filtering or mapping the result and so on.</p>
<p>This example shows you, how can you react on a login request. This stores the user data in the actual session on successful login, or injects the <code>Unauthorized</code> response into the state.</p>
<pre><code class="language-clojure">(defn update-sessions-and-db!
  "Creates and adds a new session to the server's store for the user that wants to sign-in.
   Avoids duplication by firstly removing the session that is related to this user (if it exists).
   After the session addition, it updates the user's last-login value in the database."
  [state]
  (if (valid-credentials? state)
    (let [new-session-id (str (UUID/randomUUID))
          session-backend (-&gt; state :deps :session-backend)
          user (-&gt; state :response-data :db-data first)]
      (xiana-sessions/add! session-backend new-session-id user)
      (assoc-in state [:response :headers "Session-id"] new-session-id))
    (assoc state :response {:status 401
                            :body   "Unauthorized"})))
</code></pre>
<h2><a href="#session-management" id="session-management"></a>Session management</h2>
<p>Session management has two mayor components</p>
<ul>
<li>session backend</li>
<li>session interceptors</li>
</ul>
<p>The session backend can be in-memory or persisted using a json storage in postgres database.</p>
<h3><a href="#in-memory-session-backend" id="in-memory-session-backend"></a>In memory session backend</h3>
<p>Basically it’s an atom backed session protocol implementation, allows you to <code>fetch</code> <code>add!</code> <code>delete!</code> <code>dump</code> and <code>erase!</code> session data or the whole session storage. It doesn’t require any additional configuration, and this is the default set up for handling session storage. All stored session data is wiped out on system restart.</p>
<h3><a href="#persistent-session-backend" id="persistent-session-backend"></a>Persistent session backend</h3>
<p>Instead of atom, it uses a postgresql table to store session data. Has the same protocol as in-memory. Configuration is necessary to use it.</p>
<ul>
<li>it’s necessary to have a table in postgres:</li>
</ul>
<pre><code class="language-postgres-sql">CREATE TABLE sessions (
    session_data json not null,
    session_id uuid primary key,
    modified_at timestamp DEFAULT CURRENT_TIMESTAMP
);
</code></pre>
<ul>
<li>you need to define the session’s configuration in you <code>config.edn</code> files:</li>
</ul>
<pre><code class="language-clojure"> :xiana/session-backend {:storage            :database
                         :session-table-name :sessions}
</code></pre>
<ul>
<li>
<p>in case of</p>
<ul>
<li>missing <code>:storage</code> key, <code>in-memory</code> session backend will be used</li>
<li>missing <code>:session-table-name</code> key, <code>:sessions</code> table will be used</li>
</ul>
</li>
<li>
<p>the database connection can be configured in three ways:</p>
<ul>
<li>via additional configuration</li>
</ul>
<pre><code class="language-clojure"> :xiana/session-backend {:storage            :database
                         :session-table-name :sessions
                         :port               5433
                         :dbname             "app-db"
                         :host               "localhost"
                         :dbtype             "postgresql"
                         :user               "db-user"
                         :password           "db-password"}
</code></pre>
<ul>
<li>using the same datasource as the application use:</li>
</ul>
</li>
</ul>
<p>Just init the backend after the database connection <code>clojure (defn -&gt;system [app-cfg] (-&gt; (config/config app-cfg) routes/reset db-core/connect db-core/migrate! session/init-backend ws/start))</code></p>
<pre><code>- Creating new datasource
</code></pre>
<p>If no datasource is provided on initialization, the <code>init-backend</code> function merges the database config with the session backend configuration, and creates a new datasource from the result.</p>
<h3><a href="#session-interceptors" id="session-interceptors"></a>Session interceptors</h3>
<p>The session interceptors interchanges session data between the session-backend and the app state.</p>
<p>The <code>xiana.session/interceptor</code> throws an exception when no valid session-id can be found in the headers, cookies or as query parameter.</p>
<p>The <code>xiana.session/guest-session-interceptor</code> creates a guest session if the session-id is missing, or invalid, which means:</p>
<pre><code class="language-clojure">{:session-id (UUID/randomUUID)
 :users/role :guest
 :users/id   (UUID/randomUUID)}
</code></pre>
<p>will be injected to the session data.</p>
<p>Both interceptors fetching already stored session data into the state at <code>:enter</code>, and on <code>:leave</code> updates session storage with the data from <code>(-&gt; state :session-data)</code></p>
<h2><a href="#role-based-access-and-data-ownership-control" id="role-based-access-and-data-ownership-control"></a>Role based access and data ownership control</h2>
<p>To get the benefits of <a href="https://github.com/Flexiana/tiny-rbac">tiny RBAC</a> library you need to provide the resource and the action for your endpoint in <a href="#routes">router</a> definition:</p>
<pre><code class="language-clojure">[["/api"
  ["/image" {:delete {:action     delete-action
                      :permission :image/delete}}]]]
</code></pre>
<p>and add your role-set into your app’s <a href="#dependencies-and-configuration">dependencies</a>:</p>
<pre><code class="language-clojure">(defn -&gt;system
  [app-cfg]
  (-&gt; (config/config app-cfg)
      xiana.rbac/init
      ws/start))
</code></pre>
<p>On <code>:enter</code>, the interceptor performs the permission check. It determines if the action allowed for the user found in <code>(-&gt; state :session-data :user)</code>. If access to the resource/action isn’t permitted, then the response is:</p>
<pre><code class="language-clojure">{:status 403
 :body   "Forbidden"}
</code></pre>
<p>If a permission is found, then it goes into <code>(-&gt; state :request-data :user-permissions)</code> as a parameter for data ownership processing.</p>
<p>On <code>:leave</code>, executes the restriction function found in <code>(-&gt; state :request-data :restriction-fn)</code>. The <code>restriction-fn</code> should look like this:</p>
<pre><code class="language-clojure">(defn restriction-fn
  [state]
  (let [user-permissions (get-in state [:request-data :user-permissions])]
    (cond
      (user-permissions :image/all) state
      (user-permissions :image/own) (let [session-id (get-in state [:request :headers "session-id"])
                                          session-backend (-&gt; state :deps :session-backend)
                                          user-id (:users/id (session/fetch session-backend session-id))]
                                      (update state :query sql/merge-where [:= :owner.id user-id])))))
</code></pre>
<p>The rbac interceptor must be placed between the <a href="#action">action</a> and the <a href="#database-access">db-access</a> interceptors in the interceptor chain.</p>
<h2><a href="#websockets" id="websockets"></a>WebSockets</h2>
<p>To use an endpoint to serve a WebSockets connection, you can define it on route-definition alongside the restfull action:</p>
<pre><code class="language-clojure">(def routes
  [[...]
   ["/ws" {:ws-action websocket/echo
           :action    restfull/hello}]])
</code></pre>
<p>In <code>:ws-action</code> function you can provide the reactive functions in <code>(-&gt; state :response-data :channel)</code></p>
<pre><code class="language-clojure">(:require
  ...
  [xiana.websockets :refer [router string-&gt;]]
  ...)

(defonce channels (atom {}))

(def routing
  (partial router routes string-&gt;))

(defn chat-action
  [state]
  (assoc-in state [:response-data :channel]
            {:on-receive (fn [ch msg]
                           (routing (update state :request-data
                                            merge {:ch         ch
                                                   :income-msg msg
                                                   :fallback   views/fallback
                                                   :channels   channels})))
             :on-open    (fn [ch]
                           (routing (update state :request-data
                                            merge {:ch         ch
                                                   :channels   channels
                                                   :income-msg "/welcome"})))
             :on-ping    (fn [ch data])
             :on-close   (fn [ch status] (swap! channels dissoc ch))
             :init       (fn [ch])}))
</code></pre>
<p>The creation of the actual channel happens in Xiana’s <a href="conventions.html#handler">handler</a>. All provided reactive functions have the entire <a href="conventions.html#state">state</a> to work with.</p>
<h3><a href="#websockets-routing" id="websockets-routing"></a>WebSockets routing</h3>
<p><code>xiana.websockets</code> offers a router function, which supports Xiana concepts. You can define a reitit route and use it inside WebSockets reactive functions. With Xiana <a href="conventions.html#state">state</a> and support of <a href="conventions.html#interceptors">interceptors</a>, with <a href="#interceptor-overriding">interceptor override</a>. You can define a <a href="#websockets">fallback function</a>, to handle missing actions.</p>
<pre><code class="language-clojure">(def routes
  (r/router [["/login" {:action       behave/login
                        :interceptors {:inside [interceptors/side-effect
                                                interceptors/db-access]}
                        :hide         true}]]              ;; xiana.websockets/router will not log the message 
            {:data {:default-interceptors [(interceptors/message "Incoming message...")]}}))
</code></pre>
<h3><a href="#route-matching" id="route-matching"></a>Route matching</h3>
<p>For route matching Xiana provides a couple of modes:</p>
<ul>
<li>extract from string</li>
</ul>
<p>The first word of given message as actionable symbol</p>
<ul>
<li>from JSON</li>
</ul>
<p>The given message parsed as JSON, and <code>:action</code> is the actionable symbol</p>
<ul>
<li>from EDN</li>
</ul>
<p>The given message parsed as EDN, and <code>:action</code> is the actionable symbol</p>
<ul>
<li>Probe</li>
</ul>
<p>It tries to decode the message as JSON, EDN or string in corresponding order.</p>
<p>You can also define your own matching, and use it as a parameter to <code>xiana.websockets/router</code></p>
<h2><a href="#server-sent-events-sse" id="server-sent-events-sse"></a>Server-Sent Events (SSE)</h2>
<p>Xiana contains a simple SSE solution over WebSockets protocol.</p>
<p>Initialization is done by calling <code>xiana.sse/init</code>. Clients can subscribe by a route with <code>xiana.sse/sse-action</code> as <code>:ws-action</code>. Messages are sent with <code>xiana.sse/put!</code> function.</p>
<pre><code class="language-clojure">(def routes
  [["/sse" {:action sse/sse-action}]
   ["/broadcast" {:action (fn [state]
                            (sse/put! state {:message "This is not a drill!"})
                            state)}]])

(defn -&gt;system
  [app-cfg]
  (-&gt; (config/config app-cfg)
      (route/reset routes)
      sse/init
      ws/start))

(defn -main
  [&amp; _args]
  (-&gt;system {}))
</code></pre>
<h2><a href="#scheduler" id="scheduler"></a>Scheduler</h2>
<p>To repeatedly execute a function, you can use the <code>xiana.scheduler/start</code> function. Below is an implementation of SSE ping:</p>
<pre><code class="language-clojure">(ns app.core
  (:require
    [xiana.scheduler :as scheduler]
    [clojure.core.async :as async]))

(defn ping [deps]
  (let [channel (get-in deps [:events-channel :channel])]
    (async/&gt;!! channel {:type      :ping
                        :id        (str (UUID/randomUUID))
                        :timestamp (.getTime (Date.))})))

(defn -&gt;system
  [app-cfg]
  (-&gt; (config/config)
      (merge app-cfg)
      ...
      sse/init
      (scheduler/start ping 10000)
      ...))
</code></pre>
<h2><a href="#login-implementation" id="login-implementation"></a>Login implementation</h2>
<p>Xiana framework does not have any login or logout functions, as every application has its own user management logic. Though Xiana offers all the tools to easily implement them. One of the default interceptors is the session interceptor. If included, it can validate a request only if the session already exists in session storage. To log in a user, simply add its session data to the storage. (TODO: where? What is the exact key to modify?). All sessions should have a unique UUID as session-id. The active session lives under <code>(-&gt; state :session-data)</code>. On every request, before reaching the action defined by the route, the interceptor checks <code>[:headers :session-id]</code> among other things. Which is the id of the current session. The session is then loaded in session storage. If the id is not found, the execution flow is interrupted with the response:</p>
<pre><code class="language-clojure">{:status 401
 :body   "Invalid or missing session"}
</code></pre>
<p>To implement login, you need to <a href="tutorials.html#interceptor-overriding">use the session interceptor</a> in</p>
<pre><code class="language-clojure">(let [;; Create a unique ID
      session-id (UUID/randomUUID)]
  ;; Store a new session in session storage
  (add! session-storage session-id {:session-id session-id})
  ;; Make sure session-id is part of the response
  (assoc-in state [:response :headers :session-id] (str session-id)))
</code></pre>
<p>or use the <code>guest-session</code> interceptor, which creates a guest session for unknown, or missing sessions.</p>
<p>For role-based access control, you need to store the actual user in your session data. First, you’ll have to query it from the database. It is best placed in models/user namespace. Here’s an example:</p>
<pre><code class="language-clojure">(defn fetch-query
  [state]
  (let [login (-&gt; state :request :body-params :login)]
    (-&gt; (select :*)
        (from :users)
        (where [:and
                :is_active
                [:or
                 [:= :email login]
                 [:= :username login]]]))))
</code></pre>
<p>To execute it, place <code>db-access</code> interceptor in the interceptors list. It injects the query result into the state. If you already have this injected, you can modify your create session function like this:</p>
<pre><code class="language-clojure">(let [;; Get user from database result
      user (-&gt; state :response-data :db-data first)
      ;; Create session
      session-id (UUID/randomUUID)]
  ;; Store the new session in session storage. Notice the addition of user. 
  (add! session-storage session-id (assoc user :session-id session-id))
  ;; Make sure session-id is part of the response
  (assoc-in state [:response :headers :session-id] (str session-id)))
</code></pre>
<p>Be sure to remove user’s password and any other sensitive information before storing it:</p>
<pre><code class="language-clojure">(let [;; Get user from database result
      user (-&gt; state
               :response-data
               :db-data
               first
               ;; Remove password for session storage
               (dissoc :users/password))
      ;; Create session id
      session-id (UUID/randomUUID)]
  ;; Store the new session in session storage
  (add! session-storage session-id (assoc user :session-id session-id))
  ;; Make sure session-id is part of the response
  (assoc-in state [:response :headers :session-id] (str session-id)))
</code></pre>
<p>Next, we check if the credentials are correct, so we use an <code>if</code> statement.</p>
<pre><code class="language-clojure">(if (valid-credentials?)
  (let [;; Get user from database result
        user (-&gt; state
                 :response-data
                 :db-data
                 first
                 ;; Remove password for session storage
                 (dissoc :users/password))
        ;; Create session ID
        session-id (UUID/randomUUID)]
    ;; Store the new session in session storage
    (add! session-storage session-id (assoc user :session-id session-id))
    ;; Make sure session-id is part of the response
    (assoc-in state [:response :headers :session-id] (str session-id)))
  (throw (ex-info "Missing session data"
                  {:xiana/response
                   {:body   "Login failed"
                    :status 401}})))
</code></pre>
<p>Xiana provides <code>xiana.hash</code> to check user credentials:</p>
<pre><code class="language-clojure">(defn- valid-credentials?
  "It checks that the password provided by the user matches the encrypted password from the database."
  [state]
  (let [user-provided-pass (-&gt; state :request :body-params :password)
        db-stored-pass (-&gt; state :response-data :db-data first :users/password)]
    (and user-provided-pass
         db-stored-pass
         (hash/check state user-provided-pass db-stored-pass))))
</code></pre>
<p>The login logic is done, but where to place it?</p>
<p>Do you remember the <a href="./interceptors.html#side-effect">side effect interceptor</a>? It’s running after we have the query result from the database, and before the final response is rendered with the <a href="./interceptors.html#view">view interceptor</a>. The place for the function defined above is in the interceptor chain. How does it go there? Let’s see an <a href="./conventions.html#action">action</a></p>
<pre><code class="language-clojure">(defn action
  [state]
  (assoc state :side-effect side-effects/login))
</code></pre>
<p>This is the place for injecting the database query, too:</p>
<pre><code class="language-clojure">(defn action
  [state]
  (assoc state :side-effect side-effects/login
               :query model/fetch-query))
</code></pre>
<p>But some tiny thing is still missing. The definition of the response in the all-ok case. A happy path response.</p>
<pre><code class="language-clojure">(defn login-success
  [state]
  (let [id (-&gt; state :response-data :db-data first :users/id)]
    (-&gt; state
        (assoc-in [:response :body]
                  {:view-type "login"
                   :data      {:login   "succeed"
                               :user-id id}})
        (assoc-in [:response :status] 200))))
</code></pre>
<p>And finally the <a href="tutorials.html#view">view</a> is injected in the action function:</p>
<pre><code class="language-clojure">(defn action
  [state]
  (assoc state :side-effect side-effects/login
               :view view/login-success
               :query model/fetch-query))
</code></pre>
<h2><a href="#logout-implementation" id="logout-implementation"></a>Logout implementation</h2>
<p>To do a logout is much easier than a login implementation. The <code>session-interceptor</code> does half of the work, and if you have a running session, then it will not complain. The only thing you should do is to remove the actual session from the <code>state</code> and from session storage. Something like this:</p>
<pre><code class="language-clojure">(defn logout
  [state]
  (let [session-store (get-in state [:deps :session-backend])
        session-id (get-in state [:session-data :session-id])]
    (session/delete! session-store session-id)
    (dissoc state :session-data)))
</code></pre>
<p>Add the <code>ok</code> response</p>
<pre><code class="language-clojure">(defn logout-view
  [state]
  (-&gt; state
      (assoc-in [:response :body]
                {:view-type "logout"
                 :data      {:logout "succeed"}})
      (assoc-in [:response :status] 200)))
</code></pre>
<p>and use it:</p>
<pre><code class="language-clojure">(defn logout
  [state]
  (let [session-store (get-in state [:deps :session-backend])
        session-id (get-in state [:session-data :session-id])]
    (session/delete! session-store session-id)
    (-&gt; state
        (dissoc :session-data)
        (assoc :view views/logout-view))))
</code></pre>
<h2><a href="#access-and-data-ownership-control" id="access-and-data-ownership-control"></a>Access and data ownership control</h2>
<p><a href="./tutorials.html#role-based-access-and-data-ownership-control">RBAC</a> is a handy way to restrict user actions on different resources. It’s a role-based access control and helps you to implement data ownership control. The <code>rbac/interceptor</code> should be placed <a href="./tutorials.html#interceptor-overriding">inside</a> <a href="./interceptors.html#db-access">db-access</a>.</p>
<h3><a href="#role-set-definition" id="role-set-definition"></a>Role set definition</h3>
<p>For <a href="https://github.com/Flexiana/tiny-rbac">tiny-RBAC</a> you should provide a <a href="https://github.com/Flexiana/tiny-rbac#builder">role-set</a>. It’s a map which defines the application resources, the actions on it, the roles with the different granted actions, and restrictions for data ownership control. This map must be placed in <a href="./conventions.html#dependencies">deps</a>.</p>
<p>Here’s an example role-set for an image service:</p>
<pre><code class="language-clojure">(def role-set
  (-&gt; (b/add-resource {} :image)
      (b/add-action :image [:upload :download :delete])
      (b/add-role :guest)
      (b/add-inheritance :member :guest)
      (b/add-permission :guest :image :download :all)
      (b/add-permission :member :image :upload :all)
      (b/add-permission :member :image :delete :own)))
</code></pre>
<p>It defines a role-set with:</p>
<ul>
<li>an <code>:image</code> resource,</li>
<li><code>:upload :download :delete</code> actions on <code>:image</code> resource</li>
<li>a <code>:guest</code> role, who can download all the images</li>
<li>a <code>:member</code> role, who inherits all of <code>:guest</code>’s roles, can upload <code>:all</code> images, and delete <code>:own</code> images.</li>
</ul>
<h3><a href="#provide-resourceaction-at-routing" id="provide-resourceaction-at-routing"></a>Provide resource/action at routing</h3>
<p>The resource and action can be defined on route definition. The RBAC interceptor will check permissions against what is defined here:</p>
<pre><code class="language-clojure">(def routes
  [["/api" {:handler handler-fn}
    ["/image" {:get    {:action     get-image
                        :permission :image/download}
               :put    {:action     add-image
                        :permission :image/upload}
               :delete {:action     delete-image
                        :permission :image/delete}}]]])
</code></pre>
<h3><a href="#application-start-up" id="application-start-up"></a>Application start-up</h3>
<pre><code class="language-clojure">(def role-set
  (-&gt; (b/add-resource {} :image)
      (b/add-action :image [:upload :download :delete])
      (b/add-role :guest)
      (b/add-inheritance :member :guest)
      (b/add-permission :guest :image :download :all)
      (b/add-permission :member :image :upload :all)
      (b/add-permission :member :image :delete :own)))

(def routes
  [["/api" {:handler handler-fn}
    ["/login" {:action       login
               :interceptors {:except [session/interceptor]}}]
    ["/image" {:get    {:action     get-image
                        :permission :image/download}
               :put    {:action     add-image
                        :permission :image/upload}
               :delete {:action     delete-image
                        :permission :image/delete}}]]])

(defn -&gt;system
  [app-cfg]
  (-&gt; (config/config)
      (merge app-cfg)
      session-backend/init-backend
      routes/reset
      db-core/connect
      db-core/migrate!
      ws/start))

(def app-cfg
  {:routes                  routes
   :role-set                role-set
   :controller-interceptors [interceptors/params
                             session/interceptor
                             rbac/interceptor
                             interceptors/db-access]})

(defn -main
  [&amp; _args]
  (-&gt;system app-cfg))

</code></pre>
<h3><a href="#access-control" id="access-control"></a>Access control</h3>
<p>Prerequisites:</p>
<ul>
<li>role-set in <code>(-&gt; state :deps :role-set)</code></li>
<li>route definition has <code>:permission</code> key</li>
<li>user’s role is in <code>(-&gt; state :session-data :users/role)</code></li>
</ul>
<p>If the <code>:permission</code> key is missing, all requests are going to be <strong>granted</strong>. If <code>role-set</code> or <code>:users/role</code> is missing, all requests are going to be <strong>denied</strong>.</p>
<p>When <code>rbac/interceptor</code> <code>:enter</code> is executed, it checks if the user has any permission on the pre-defined <code>resource/action</code> pair. If there is any, it collects all of them (including inherited permissions) into a set of format: <code>:resource/restriction</code>.</p>
<p>For example:</p>
<pre><code class="language-clojure">:image/own
</code></pre>
<p>means the given user is granted the permission to do the given <code>action</code> on <code>:own</code> <code>:image</code> resource. This will help you to implement <a href="#data-ownership">data ownership</a> functions. This set is associated in <code>(-&gt; state :request-data :user-permissions)</code></p>
<p>If user cannot perform the given action on the given resource (neither by inheritance nor by direct permission), the interceptor will interrupt the execution flow with the response:</p>
<pre><code class="language-clojure">{:status 403
 :body   "Forbidden"}
</code></pre>
<h3><a href="#data-ownership" id="data-ownership"></a>Data ownership</h3>
<p>Data ownership control is about restricting database results only to the elements on which the user is able to perform the given action. In the context of the example above, it means <code>:member</code>s are able to delete only the owned <code>:image</code>s. At this point, you can use the result of the <a href="#access-control">access control</a> from the state. Continuing with the same example.</p>
<p>From this generic query</p>
<pre><code class="language-clojure">{:delete [:*]
 :from   [:images]
 :where  [:= :id (get-in state [:params :image-id])]}
</code></pre>
<p>you want to switch to something like this:</p>
<pre><code class="language-clojure">{:delete [:*]
 :from   [:images]
 :where  [:and
          [:= :id (get-in state [:params :image-id])]
          [:= :owner.id user-id]]}
</code></pre>
<p>To achieve this, you can simply provide a <code>restriction function</code> into <code>(-&gt; state :request-data :restriction-fn)</code> The <code>user-permissions</code> is a set, so it can be easily used for making conditions:</p>
<pre><code class="language-clojure">(defn restriction-fn
  [state]
  (let [user-permissions (get-in state [:request-data :user-permissions])]
    (cond
      (user-permissions :image/own) (let [user-id (get-in state [:session-data :users/id])]
                                      (update state :query sql/merge-where [:= :owner.id user-id]))
      :else state)))
</code></pre>
<p>And finally, the only missing piece of code: the model, and the action</p>
<pre><code class="language-clojure">
(defn delete-query
  [state]
  {:delete [:*]
   :from   [:images]
   :where  [:= :id (get-in state [:params :image-id])]})

(defn delete-image
  [state]
  (-&gt; state
      (assoc :query (delete-query state))
      (assoc-in [:request-data :restriction-fn] restriction-fn)))
</code></pre>
</div></div></div></body></html>