<p><img src="resources/images/Xiana.png" width="242"></p><h1 id="conventions">Conventions</h1><ul><li><a href='#overview'>Overview</a></li><li><a href='#state'>State</a></li><li><a href='#action'>Action</a></li><li><a href='#handler'>Handler</a></li><li><a href='#dependencies'>Dependencies</a></li><li><a href='#interceptors'>Interceptors</a></li><li><a href='#interceptors_error_handling'>Interceptors error handling</a></li></ul><h2 id="overview">Overview</h2><p>The diagram bellow gives you an overview, how a request is processed in Xiana based applications. <img src="./conventions-1.svg" alt="diagram" /><h2 id="state">State</h2></p><p>State is created for each HTTP request and represents the current state of the application. It contains:</p><ul><li>the application's dependencies and configuration</li><li>request</li><li>request-data</li><li>response</li></ul><p>This structure is very volatile, will be updated quite often on the application's life cycle.</p><p>The main modules that update the state are:</p><ul><li>Routes:</li></ul><p>  Add information from the matched route to the state map</p><ul><li>Interceptors:</li></ul><p>  Add, consumes or remove information from the state map. More details in <a href='#interceptors'>Interceptors</a> section.</p><ul><li>Actions:</li></ul><p>  In actions, you are able to interfere with the :leave parts of the interceptors.</p><p>At the last step of execution the handler extracts the response value from the state.</p><p>The state is renewed on every request.</p><h2 id="action">Action</h2><p>The action conventionally is the control point of the application flow. This is the place were you can define how the rest of your execution flow would behave. Here you can provide the database query, restriction function, the view, and the additional side effect functions are you want to execute.</p><p>Actions are defined in the routes vector</p><pre><code class="clojure">&#91;&quot;/&quot; {:get {:action #&#40;do something&#41;}}&#93;
</code></pre><h2 id="handler">Handler</h2><p>Xiana's handler creates the state for every request, matches the appropriate route, executes the interceptors, handles interceptor overrides, and not-found cases. It handles websocket requests too.</p><h2 id="routing">Routing</h2><p>Routing means selecting the actions to execute depending on the request URL, and HTTP method.</p><h2 id="dependencies">Dependencies</h2><p>Modules can depend on external resources, configurations, as well as on other modules. These dependencies are added to the state on state creation, and defined on application startup.</p><h2 id="interceptors">Interceptors</h2><p>An interceptor is a pair of unary functions. Each function must recieve and return a state map. You can look at it as on an analogy to AOP's around aspect, or as on a pair of middlewares. They work mostly the same way as <a href='http://pedestal.io/reference/interceptors'>pedestal</a> and <a href='https://github.com/metosin/sieppari'>sieppari</a> interceptors. Xiana provides a set of base interceptors, for the most common use cases.</p><p>This figure shows how interceptors are executed ideally: <img src="./conventions-2.svg" alt="diagram" /><h2 id="interceptors&#95;error&#95;handling:">Interceptors error handling:</h2></p><p>The interceptor executor handles the exceptional states like sieppari does. If an exception happens, it tries to handle first in the same interceptor. If it has and <code>:error</code> handler, it will call it, otherwise it'll search for <code>:error</code> handlers for the beginning of the interceptor queue. When and <code>:error</code> function found, and matched with the given exception, the executor calls the queue <code>:leave</code> functions in reserved order, where the handler has been found.</p><p>This diagram shows how the error cases handled: <img src="./conventions-3.svg" alt="diagram" /></p>